/**********************************************************************************
 * Copyright (c) 2020 Loren M. Lang                                               *
 *                                                                                *
 * Permission is hereby granted, free of charge, to any person obtaining a copy   *
 * of this software and associated documentation files (the "Software"), to deal  *
 * in the Software without restriction, including without limitation the rights   *
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell      *
 * copies of the Software, and to permit persons to whom the Software is          *
 * furnished to do so, subject to the following conditions:                       *
 *                                                                                *
 * The above copyright notice and this permission notice shall be included in all *
 * copies or substantial portions of the Software.                                *
 *                                                                                *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     *
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       *
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    *
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER         *
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  *
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  *
 * SOFTWARE.                                                                      *
 **********************************************************************************/

/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package amsat

import kotlin.test.Test
import kotlin.test.assertNotNull
import kotlin.test.assertEquals

import java.text.SimpleDateFormat
import java.text.ParseException
import java.util.TimeZone
import java.util.Calendar
import java.util.GregorianCalendar
import java.util.Date
//import java.io.Reader
import java.io.BufferedReader
import java.io.InputStreamReader
//import java.io.InputStream
import java.io.BufferedInputStream
import java.nio.charset.Charset
import java.nio.charset.StandardCharsets

import org.json.JSONTokener
import org.json.JSONObject
import org.json.JSONArray

//import org.junit.Test
//import static org.junit.Assert.*

//import org.apache.http.HttpEntity
import org.apache.http.client.methods.HttpGet
//import org.apache.http.client.methods.CloseableHttpResponse
import org.apache.http.impl.client.CloseableHttpClient
import org.apache.http.impl.client.HttpClients
import org.apache.http.util.EntityUtils

import com.google.api.client.http.apache.v2.ApacheHttpTransport

import com.github.paweladamski.httpclientmock.HttpClientMock
import com.google.api.client.http.GenericUrl
import com.google.api.client.http.HttpRequest


class AppTest {
    @Test
    fun testHttpClient() {
        val httpclient = HttpClients.createDefault() //as CloseableHttpClient
        val httpGet = HttpGet("http://www.google.com/")
        httpclient.execute(httpGet).use {
            println(it.getStatusLine())
            val entity1 = it.getEntity()
            // do something useful with the response body
            // and ensure it is fully consumed
            EntityUtils.consume(entity1)
        }
    }

    @Test
    fun testAmsatApi() {
        val httpclient = HttpClients.createDefault()
        val httpGet = HttpGet("https://amsat.org/status/api/v1/sat_info.php?name=AO-91&hours=24")
        httpclient.execute(httpGet).use { response1 ->
            println(response1.getStatusLine())
            val entity1 = response1.getEntity()
            val body = BufferedInputStream(entity1.getContent())
            val textBuilder = StringBuilder()
            BufferedReader(InputStreamReader
                (body, Charset.forName(StandardCharsets.UTF_8.name()))).use { reader ->
                var c = reader.read()
                while (c != -1) {
                    textBuilder.append(c)
                    c = reader.read()
                }
            }
            // do something useful with the response body
            // and ensure it is fully consumed
            EntityUtils.consume(entity1)
        }
    }

    @Test
    fun testBasicJsonObject() {
        val json = "{" +
                "  \"query\": \"Pizza\", " +
                "  \"locations\": [ 94043, 90210 ] " +
                "}"

        val `object` = JSONTokener(json).nextValue() as JSONObject
        val _query = `object`.getString("query")
        val locations = `object`.getJSONArray("locations")
        println(locations.getInt(0))
    }

    @Test
    fun testSatelliteJson() {
        val json =
            "[{\"name\":\"AO-91\",\"reported_time\":\"2020-08-20T06:30:00Z\",\"callsign\":\"W6WW\",\"report\":\"Heard\",\"grid_square\":\"DM14\"},{\"name\":\"AO-91\",\"reported_time\":\"2020-08-20T04:30:00Z\",\"callsign\":\"YD0NXX\",\"report\":\"Heard\",\"grid_square\":\"OI33js\"},{\"name\":\"AO-91\",\"reported_time\":\"2020-08-19T18:30:00Z\",\"callsign\":\"KC7MG\",\"report\":\"Heard\",\"grid_square\":\"DM42\"},{\"name\":\"AO-91\",\"reported_time\":\"2020-08-19T18:30:00Z\",\"callsign\":\"AA5PK\",\"report\":\"Heard\",\"grid_square\":\"DM91\"},{\"name\":\"AO-91\",\"reported_time\":\"2020-08-19T17:30:00Z\",\"callsign\":\"WA5KBH\",\"report\":\"Heard\",\"grid_square\":\"EM30\"},{\"name\":\"AO-91\",\"reported_time\":\"2020-08-19T15:30:00Z\",\"callsign\":\"KB9STR\",\"report\":\"Heard\",\"grid_square\":\"EM69\"},{\"name\":\"AO-91\",\"reported_time\":\"2020-08-19T10:30:00Z\",\"callsign\":\"OE\\/PE4KH\",\"report\":\"Heard\",\"grid_square\":\"JN47\"},{\"name\":\"AO-91\",\"reported_time\":\"2020-08-19T10:30:00Z\",\"callsign\":\"OK1VDD\",\"report\":\"Heard\",\"grid_square\":\"JO70ec\"},{\"name\":\"AO-91\",\"reported_time\":\"2020-08-19T10:30:00Z\",\"callsign\":\"OZ1MY\",\"report\":\"Heard\",\"grid_square\":\"JO65fr\"},{\"name\":\"AO-91\",\"reported_time\":\"2020-08-19T09:30:00Z\",\"callsign\":\"OZ1MY\",\"report\":\"Heard\",\"grid_square\":\"JO65fr\"},{\"name\":\"AO-91\",\"reported_time\":\"2020-08-19T07:30:00Z\",\"callsign\":\"W6WW\",\"report\":\"Heard\",\"grid_square\":\"DM14\"},{\"name\":\"AO-91\",\"reported_time\":\"2020-08-19T07:30:00Z\",\"callsign\":\"OZ1MY\",\"report\":\"Heard\",\"grid_square\":\"JO65fr\"},{\"name\":\"AO-91\",\"reported_time\":\"2020-08-19T06:30:00Z\",\"callsign\":\"W6WW\",\"report\":\"Heard\",\"grid_square\":\"DM14\"}]"

        val list = JSONTokener(json).nextValue() as JSONArray

        val entry = list.get(0) as JSONObject
        val name = entry.getString("name")
        assertEquals(name, "AO-91")
        val callsign = entry.getString("callsign")
        assertEquals(callsign, "W6WW")
        val grid = entry.getString("grid_square")
        assertEquals(grid, "DM14")
        val time = entry.getString("reported_time")
        assertEquals(time, "2020-08-20T06:30:00Z")
        val report = entry.getString("report")
        assertEquals(report, "Heard")

        val entry2 = list.get(6) as JSONObject
        val name2 = entry2.getString("name")
        assertEquals(name2, "AO-91")
        val callsign2 = entry2.getString("callsign")
        assertEquals(callsign2, "OE/PE4KH")
        val grid2 = entry2.getString("grid_square")
        assertEquals(grid2, "JN47")
        val time2 = entry2.getString("reported_time")
        assertEquals(time2, "2020-08-19T10:30:00Z")
        val report2 = entry2.getString("report")
        assertEquals(report2, "Heard")
    }

    @Test
    fun testMockHttpClient() {
        val json = "[{" +
                "\"name\":\"AO-91\"," +
                "\"reported_time\":\"2020-08-20T06:30:00Z\"," +
                "\"callsign\":\"W6WW\"," +
                "\"report\":\"Heard\"," +
                "\"grid_square\":\"DM14\"" +
                "}]"

        val url = "http://localhost/login"
        val httpClientMock = HttpClientMock()
        httpClientMock.onGet(url)
            .doReturn(json)

        val httpGet = HttpGet(url)
        httpClientMock.execute(httpGet).use { response1 ->
            val entity1 = response1.getEntity()
            val body = BufferedInputStream(entity1.getContent())
            val textBuilder = StringBuilder()
            BufferedReader(InputStreamReader
                (body, Charset.forName("UTF-8"))).use { reader ->
                var c = reader.read()
                while (c != -1) {
                    textBuilder.append(c.toChar())
                    c = reader.read()
                }
            }

            assertEquals(textBuilder.toString(), json)
            val list = JSONTokener(textBuilder.toString()).nextValue() as JSONArray

            val entry = list.get(0) as JSONObject
            val name = entry.getString("name")
            assertEquals(name, "AO-91")
            val callsign = entry.getString("callsign")
            assertEquals(callsign, "W6WW")
            val grid = entry.getString("grid_square")
            assertEquals(grid, "DM14")
            val time = entry.getString("reported_time")
            assertEquals(time, "2020-08-20T06:30:00Z")
            val report = entry.getString("report")
            assertEquals(report, "Heard")

            EntityUtils.consume(entity1)
        }
    }

    @Test
    fun testDateParsing() {
        val date = "2020-08-20T06:30:00Z"
        val parser = SimpleDateFormat("yyyy-MM-dd'T'hh:mm:ss'Z'")
        val result = parser.parse(date)
        assertEquals(result.year + 1900, 2020)
        assertEquals(result.month + 1, 8)
        assertEquals(result.date, 20)
        assertEquals(result.hours, 6)
        assertEquals(result.minutes, 30)
        assertEquals(result.seconds, 0)
    }

    @Test
    fun testCalendarParsing() {
        val dateStr = "2020-08-20T06:30:00Z"
        val calendar = GregorianCalendar.getInstance(TimeZone.getTimeZone("UTC"))
        var s = dateStr.replace("Z", "+00:00")
        try {
            s = s.substring(0, 22) + s.substring(23)  // to get rid of the ":"
        } catch (e: IndexOutOfBoundsException) {
            throw ParseException("Invalid length", 0)
        }
        val date = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s)
        calendar.time = date

        assertEquals(2020, calendar.get(Calendar.YEAR))
        assertEquals(8, calendar.get(Calendar.MONTH) + 1)
        assertEquals(20, calendar.get(Calendar.DAY_OF_MONTH))
        assertEquals(6, calendar.get(Calendar.HOUR_OF_DAY))
        assertEquals(30, calendar.get(Calendar.MINUTE))
        assertEquals(0, calendar.get(Calendar.SECOND))
    }

    @Test
    fun testGoogleHttpClient() {
        val httpclient = HttpClients.createDefault()
        val transport = ApacheHttpTransport(httpclient)
        val request: HttpRequest = transport.createRequestFactory().buildGetRequest(
            GenericUrl("http://www.google.com/")
        );
        val rawResponse = request.execute().parseAsString()
        println(rawResponse)
    }
}
